[Work] Produce Low Memory Killer situation on purpose!!
[課題] Low Memory Killer を意図的に発生させたい
<ja>
  Androidは、ヒープが涸渇すると、使われていないアプリをKillする機能があります。
  KyoroStressV2では、意図的にのこの現象を発生させるアプリです。

     おおまかな仕組みは、単純にたくさんヒープを使用してあげるだけです。
     なので、byte配列でもガバッととってあげれば、それだけで済むだけに思えます。

    しかし、ひとつのアプリ(プロセス)が取得できるヒープの量は制限がされています。
    このため、ただ単純にヒープを大量に消費するアプリを作れば良いとはならないのです。

    また、当然ではありますが、このヒープを大量に消費しているアプリも、PFからKILLさせる対象ですから。
   殺される事を前提としなければならません。

   では、KyoroStressV2/V1での解決方法を解説します。
</ja>
<en>

</en>

[KyoroTextでの解決方法]
 　KyoroStressでは、「 複数のServiceを、各々別プロセスで立つあげる。各々Serviceでヒープを大量に消費する。」という方法をとっています。
    こうすることで、最初にあげた問題が解決できます。  

   -(松) ひとつのアプリで消費できるヒープが制限されているため、ひとつのアプリで端末のヒープが涸渇しててる状態をつくれない。
   -(竹) ヒープを涸渇しているアプリがPFにKILLされる場合がある。
   といった問題がありました。
  　(松)については、複数のプロセスを立ち上げれば、プロセス×ひとつのアプリで取得可能なヒープのサイズだけ取得できます。
  (竹)についても、生きているプロセスが殺されているプロセスの分もヒープを消費すればよいのです。
   という感じにうまく解決できます。


[使い方]
  KyoroStressV2 
   　# start 
         ヒープの消費を開始します。
         ヒープの消費率監視を開始する。
  # stop
         ヒープの消費を終了する。そして、開放する。
  # num of big eater
         起動するプロセスの数
  # eatup java heap size
         ひとつのプロセスが消費するヒープサイズ
  # is retry
         オンならば、ヒープを確保できるまで、何度もトライする。
  # show notification
         オンならば、Notificaiotn表示をする。
　　# lowMoemory
    true ならば、 ロウメモリー状態
  # availMemory
　　　使用可能なメモリ
  # threshold
        この値よりも低い場合は、ロウメモリー状態
  #　dalvik.vm.heapsize 
       ひとつのプロセスがandroid:largeHeap="true"の時に使用可能なJavaヒープ
  #　dalvik.vm.heapgrowthlimit
    android:largeHeap="false"の時に使用可能なJavaヒープ
  # lahalito"
         ヒープ消費中
  # kadorto
         他サービスを復活中
  # done all task
 　　　 すべての作業を完了した。もう何もすることはない。

[BigEaterの動作]
  - 1. 指定されたヒープを取得する。
     is retry が true の時、指定されたヒープを取得できるまで、1を何度も繰り返す。
  - 2. KILLされたサービスを復活させる。
       is retry が true の時、Threadが死ぬまで、何度も2を繰り返す。
  - 3. 終了
 
[次回]
   より、詳細な仕組みは別の記事で解説します。
 - Serviceごとに、別プロセスにする方法は？
 - アプリが使用可能なヒープを調べる方法は？
 - Low Memory 状態を取得する方法は？
 - 制限を越えてヒープを取得する方法？




